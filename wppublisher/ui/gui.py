import datetime

from PyQt5.QtCore import *
from PyQt5.QtWidgets import (QMainWindow, QFileDialog)

from ui import generated
from push import publish
from initialize import install
from multithreading import workers


'''
The qt gui class is generated by pyuic5
Due to it being a generated class, it is not edited directly.
Instead, this class wraps around it.
'''


class App(QMainWindow):
    def __init__(self, *args, **kwargs):
        super(App, self).__init__(*args, **kwargs)
        self.init_ui()
        self.publish_variables = {}
        self.installation_variables = {}

        self.threadpool = QThreadPool()
        print("Multithreading with maximum %d threads" % self.threadpool.maxThreadCount())

    def get_installation_variables(self):
        database_variables = {
            'hostname': self.ui.installation_database_hostname_text.text(),
            'username': self.ui.installation_database_password_text.text(),
            'password': self.ui.installation_database_username_text.text()
        }

        self.installation_variables = {
            'path': self.ui.installation_path_text.text(),
            'site_url': self.ui.installation_site_url_text.text(),
            'username': self.ui.installation_username_text.text(),
            'wordmove_config': self.ui.wordmove_checkbox.isChecked(),
            'database': database_variables
        }

    def get_publish_variables(self):
        self.publish_variables = {
            'cloud_service': 'Digital Ocean',
            'api_key': self.ui.publish_api_key_text.text(),
            'installation_path': self.ui.publish_installation_path_text.text(),
            'site_url': self.ui.publish_site_url_text.text()
        }

    def field_validation(self, field_section):
        if field_section == 'installation':
            self.get_installation_variables()

            if self.installation_variables['path'] == '':
                message = 'Installation path is empty'
                result = False
            elif self.installation_variables['site_url'] == '':
                message = 'Site Url is empty'
                result = False
            elif self.installation_variables['database']['hostname'] == '':
                message = 'Database hostname is empty'
                result = False
            else:
                message = 'No issues found, starting installation...'
                result = True
        elif field_section == 'publish':
            self.get_publish_variables()
            message = 'No issues found, starting publication...'
            result = True

        timestamp_format = '[%H:%M:%S]'
        timestamp = datetime.datetime.now().strftime(timestamp_format)

        timestamped_message = str(timestamp) + ' ' + message
        self.statusBar().showMessage(timestamped_message)
        self.show()

        return result

    def set_installation_path(self):
        dialogue_title = 'Select the folder where you would like to install wordpress'
        folder_name = QFileDialog.getExistingDirectory(self, dialogue_title)
        installation_path = self.ui.installation_path_text
        installation_path.setText(folder_name)

    def set_publish_path(self):
        dialogue_title = 'Select the wordpress installation you would like to publish'
        folder_name = QFileDialog.getExistingDirectory(self, dialogue_title)
        publish_path = self.ui.publish_installation_path_text
        publish_path.setText(folder_name)

    def start_thread(self):
        # Pass the function to execute
        worker = workers.Worker(self.start_install) # Any other args, kwargs are passed to the run function
        worker.signals.result.connect(self.print_output)
        worker.signals.finished.connect(self.thread_complete)
        worker.signals.progress.connect(self.progress_fn)

        # Execute
        self.threadpool.start(worker)

    def start_install(self):
        if self.field_validation('installation'):
            installation = install.Wordpress(self.installation_variables)
            installation.run()

    def start_publish(self, progress_callback):
        if self.field_validation('publish'):
            # Create a new server
            progress_callback.emit('emitting something')
            if self.publish_variables['cloud_service'] == 'Digital Ocean':
                vps = publish.ServerInit(self.publish_variables)
                ipv4_address, username, password = vps.run()
                progress_callback.emit('emitting something x')


            '''
            Connect to server and perform all necessary configuration
            '''
            vps_configuration = publish.Configuration(ipv4_address, username, password, vps, self.publish_variables)
            vps_configuration.run()

    def print_output(self, s):
        print(s)

    def thread_complete(self):
        print("THREAD COMPLETE!")

    def progress_fn(self, log):
        #self.ui.logs_output_text_box.append('bleh')
        #self.ui.logs_output_text_box.update()
        self.ui.logs_output_text_box.setText(log)
        print("almost done")

    def publish_trigger(self):
        # Pass the function to execute
        worker = workers.Worker(self.start_publish)
        worker.signals.finished.connect(self.thread_complete)
        worker.signals.result.connect(self.print_output)
        worker.signals.progress.connect(self.progress_fn)

        # Execute
        self.threadpool.start(worker)

    def init_ui(self):
        self.ui = generated.Ui_MainWindow()
        self.ui.setupUi(self)

        # File path selectors
        installation_path_selector = self.ui.installation_path_file_selector
        installation_path_selector.clicked.connect(self.set_installation_path)

        publish_path_selector = self.ui.publish_installation_path_selector
        publish_path_selector.clicked.connect(self.set_publish_path)

        # Start buttons
        installation_start_button = self.ui.installation_start_button
        installation_start_button.clicked.connect(self.start_install)

        publish_start_button = self.ui.publish_start_button
        publish_start_button.clicked.connect(self.publish_trigger)

        self.show()